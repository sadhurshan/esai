1. ~~app/Support/Security/VirusScanner.php:12-34 – The “virus scan” hook always short-circuits unless both SECURITY_SCAN_UPLOADS=true and a non-stub driver are configured, and even then there is no implementation (explicit TODO). documents.md and the “Data & Integrations” section of copilot-instructions.md require every uploaded document/CAD file to be scanned before persistence, so right now RFQ CAD uploads (and every other document flow that calls VirusScanner::assertClean) skip the mandated protection. That is a launch‑blocking security gap because malicious files can be stored without any inspection or quarantine.~~ **(Fixed)** — Replaced the stub hook with a driver-based scanner that enforces uploads to run through the configured driver (ClamAV by default), throws if scanning is disabled in production, exposes failure/detection exceptions, and documents the required SECURITY_SCAN_* / CLAMAV_* env vars.

2. ~~app/Http/Controllers/Api/GoodsReceiptNoteController.php:36-118 (companyIndex) – The company GRN listing wraps pagination metadata inside data.meta and never passes the $meta argument to ok(). According to API_ENVELOPE.md and the acceptance checklist for collections (ACCEPTANCE.md, “API: GET /api/suppliers returns … data.items … meta.next_cursor”), collection responses must emit data.items plus a top-level meta.next_cursor/meta.prev_cursor. Because this endpoint nests meta under data, the shared SDK helper (api-helpers.ts) does not lift cursors into the expected meta slot, forcing clients to handle this one-off shape manually and breaking consistency with the rest of the API.~~ **(Fixed)** — The endpoint now reuses ApiController::paginate(), returns `data.items` only, and sends cursor metadata via the envelope-level `meta` block so SDK helpers can consume cursors consistently.

3. ~~app/Http/Controllers/Api/GoodsReceiptNoteController.php:187-235 (index scoped to a PO) – This route still relies on paginate()/offset pagination and returns {data.items, meta.total/current_page…}. The platform contract (see copilot-instructions.md “REST and Inertia endpoints return… collection endpoints default to cursor pagination … meta.next_cursor/meta.prev_cursor”) requires cursor-based pagination for every collection unless a deep spec explicitly calls for offsets. Nothing in receiving_quality.md grants an exception, so this endpoint violates both the contract and what the React hooks (useGrns / useGrnLines) are built around—callers cannot request a cursor token and must fall back to offset semantics unique to this route.~~ **(Fixed)** — Converted the PO-scoped listing to cursor pagination with a deterministic order (inspected_at/created_at/id) and moved pagination data into the envelope-level `meta` payload.

4. ~~app/Http/Controllers/Api/ExportController.php:29-63 – The export-request history endpoint has the same two issues: it uses paginate() (page/offset) and embeds the pagination block inside data.meta instead of the envelope-level meta. That contradicts the shared API envelope spec and prevents SDK consumers (which rely on parseEnvelope to surface cursor metadata) from accessing cursors consistently. As a result, large export histories can only be traversed via slow offset pagination, and the client libraries lose the normalized meta.nextCursor shape they expect.~~ **(Fixed)** — Export history now uses cursorPaginate() (created_at/id ordering) and passes cursor metadata through the envelope-level `meta`, keeping the collection shape identical to the rest of the API.