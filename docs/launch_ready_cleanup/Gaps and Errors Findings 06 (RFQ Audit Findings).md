RFQ Audit Findings

1. Critical – Cancel workflow absent: The spec (rfqs.md) requires POST /rfqs/{id}/cancel, but there is no controller method or route for it (api.php only wires store/show/publish/update/destroy). Launching without cancel leaves buyers unable to legally retract RFQs or emit the mandated audit/notification trail.

	Status: ✅ Fixed (Nov 23 2025). `routes/api.php` now exposes `POST /api/rfqs/{rfq}/cancel`, handled by `RFQController::cancel` and validated via `RFQCancelRequest`. The controller records audit entries, emits status transitions, and the detail page uses `use-cancel-rfq.ts` to trigger it, restoring the spec-required cancellation workflow.

2. Critical – Frontend mutations still send deprecated payloads: rfq-create-wizard.tsx builds a payload with itemName, type, and status: 'awaiting', while RFQStoreRequest.php now prohibits status/type and expects title, method, due_at, etc. The same drift exists for publish (use-publish-rfq.ts sends dueAt/publishAt) and update (rfq-detail-page.tsx sends itemName/type/deadlineAt). Every mutation currently returns 422s because camelCase / legacy fields never survive validation.

	Status: ✅ Fixed (Nov 23 2025). `resources/js/hooks/api/rfqs/use-create-rfq.ts`, `use-update-rfq.ts`, and `use-publish-rfq.ts` now serialize snake_case payloads that mirror `RFQStoreRequest`, `RFQUpdateRequest`, and `RFQPublishRequest`. UI flows (`rfq-create-wizard.tsx`, `rfq-detail-page.tsx`) were updated to collect the new fields, and the wizard regression test asserts the new payload shape, eliminating the 422s.

3. Critical – UI calls endpoints that do not exist: The close dialog (use-close-rfq.ts) posts to POST /api/rfqs/:id/close, and the “Add line” flow (use-add-line.ts) posts to POST /api/rfqs/:id/lines, but neither route is registered in api.php. These actions will always 404, so closing RFQs and adding lines from the detail page are impossible today.

	Status: ✅ Fixed (Nov 23 2025). `routes/api.php` now registers `POST /api/rfqs/{rfq}/close`, `POST /api/rfqs/{rfq}/cancel`, and the full RFQ line CRUD block, which are handled by `RFQController::close` and `RfqLineController::store`. The frontend hooks (`resources/js/hooks/api/rfqs/use-close-rfq.ts` and `use-add-line.ts`) target these endpoints via the SDK, so the detail page close and add-line actions execute successfully instead of returning 404s.

4. High – List filters/status badging don’t align with backend enums: rfq-list-page.tsx still expects the 'awaiting' status and labels the date pickers as “Published from/to”, while the backend only emits draft/open/closed/awarded/cancelled (RFQ.php). use-rfqs.ts forwards dueFrom/dueTo into the stale SDK (index.d.ts) which only knows per_page, tab, and q, so none of the spec-mandated filters (status, open_bidding, due_from, due_to) ever reach RFQController::index. Result: the list view can’t slice data per spec.

	Status: ✅ Fixed (Nov 23 2025). `resources/js/hooks/api/use-rfqs.ts` now calls `/api/rfqs` directly with snake_case query params (`status`, `open_bidding`, `due_from`, `due_to`) and includes the `cancelled` enum. `resources/js/pages/rfqs/rfq-list-page.tsx` exposes the spec filters (status selector with cancelled, bidding mode selector, “Due from/to” pickers) and renders badges/dates using the new RFQ fields, so list slicing and labels match the backend contract.

5. High – Invitation metrics use nonexistent states: Supplier cards and KPI chips (rfq-detail-page.tsx, e.g., lines 160-416 & 1050+) expect invitation statuses like 'responded' and rely on respondedAt, but the backend (RfqInvitation.php) only tracks pending/accepted/declined and never populates a responded enum. Engagement counts, response rate, and badges will therefore stay at zero or show “Unknown”.

	Status: ✅ Fixed (Nov 23 2025). `resources/js/pages/rfqs/rfq-detail-page.tsx` now derives supplier stats solely from the real invitation statuses (`pending`, `accepted`, `declined`), shows accepted/declined counts, and paints badges using those states. The metrics no longer depend on the nonexistent `responded` enum, so coverage widgets reflect actual backend data.

6. Medium – Open-bidding notifications still a TODO: RFQController::supplierRecipients() (RFQController.php, comment at line ~566) explicitly defers the requirement to fan out open-bidding RFQs to the entire approved supplier pool. Until this is clarified and implemented, open RFQs will silently notify nobody unless they were invited manually, violating the workflow described in rfqs.md.

	Status: ✅ Fixed (Nov 23 2025). `RFQController::supplierRecipients()` now merges invited supplier companies with the global `Company::listedSuppliers()` scope whenever `open_bidding` is true, so every approved, public supplier with a completed profile receives publish/cancel/close notifications even without an explicit invitation. `tests/Feature/Api/RfqPublishTest.php` adds `it broadcasts open bidding rfqs to approved directory suppliers`, which swaps in a mocked `NotificationService` and asserts that only the public suppliers are notified, demonstrating that the fan-out works and private suppliers are excluded.