1. High – Cursor pagination still missing on key APIs: RFQController.php (§index), CompanyMemberController.php (§index), PurchaseOrderController.php (§index), GoodsReceiptNoteController.php (§companyIndex & §index), and ExportController.php (§index) all use ->paginate() and emit only offset metadata. The platform spec (rfqs.md + copilot-instructions “collection endpoints default to cursor pagination”) and the updated React hooks (use-rfqs.ts, useCompanyMembers.ts, rfq-list-page.tsx) now send cursor parameters and expect meta.next_cursor/prev_cursor. Because the responses never include cursor tokens, the RFQ and member tables cannot advance past the first page and client SDK helpers regress to guessing. Convert these queries to cursorPaginate()->withQueryString(), keep deterministic ordering (orderBy(..., 'id')), and pass the cursor block down to $this->ok(..., $meta) so the UI and SDK regain pagination. **Status: Resolved 2025-11-23**

2. High – Supplier RFQ listing leaks drafts/cancelled events: In app/Http/Controllers/Api/RFQController.php::index the supplier branch only applies open_bidding/invitation filters and then falls straight into pagination; there is no status guard. Any supplier can call GET /api/rfqs and see RFQs that are still draft, cancelled, or otherwise not yet published as soon as a buyer toggles the open_bidding flag or adds an invitation. This breaks the “Open bidding RFQs appear in supplier inboxes” workflow from rfqs.md and exposes unfinished sourcing events. Add a status filter for supplier contexts (e.g. default to status = open and explicitly exclude drafts) before executing the query. **Status: Resolved 2025-11-23**

3. Medium – RFQ mutations ignore shared company-context helper: store, publish, update, destroy, cancel, and close in RFQController.php rely on $request->user() and $user->company_id when assigning/scoping records. Every other API controller uses resolveUserCompanyId() so multi-company users operate within the currently selected tenant (copilot-instructions: “scope queries with shared BelongsToCompany patterns and never leak cross-tenant data”). As written, a user whose users.company_id is null or points at a different company (very common after switching tenants via company_user) will be blocked from creating/publishing RFQs or, worse, will mutate the wrong tenant’s RFQs. Normalize these methods to call resolveRequestUser() + resolveUserCompanyId() and bail when the helper cannot resolve a context. **Status: Resolved 2025-11-23**

4. Medium – RFQ creation ignores deadline requirements: rfqs.md → “Deadlines: due_at must be in future; close_at = due_at by default.” RFQStoreRequest.php only enforces date|after:publish_at, so API callers can submit a past or null due_at, and app/Http/Controllers/Api/RFQController::store never defaults close_at. That produces RFQs that violate the spec and later fail the publish workflow (publish requires after:now, so buyers end up with drafts they can’t publish). Tighten the request rules ('due_at' => ['required','date','after:now'], set close_at = due_at server-side) so the persisted data is compliant even when clients bypass the new wizard. **Status: Resolved 2025-11-23**