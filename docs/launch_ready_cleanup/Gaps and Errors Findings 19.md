1. Critical – Anonymous RFQ quote endpoints bypass every tenant control and storage rule (RFQQuoteController.php, lines 9‑68). Both index and store run without requireCompanyContext, policies, or even resolveRequestUser, so anyone who can reach the route can enumerate RFQs and upload quotes across companies. Uploaded attachments go straight to $request->file('attachment')->store('attachments') with no virus scan, document metadata, or audit logging, violating /[REQUIREMENTS_FULL.md](http://_vscodecontentref_/1) §26, documents.md, and DEFINITION_OF_DONE.md. Fix by requiring the envelope-aware auth helper, enforcing buyer/supplier policies, routing uploads through DocumentStorer + VirusScanner, and logging via AuditLogger.

	_Status: ✅ RFQ quote routes now live behind authenticated `Route::prefix('rfq-quotes')` guards; `app/Http/Controllers/Api/RFQQuoteController.php` resolves company context, enforces buyer vs supplier scope, runs attachments through `DocumentStorer` + `VirusScanner`, logs via `AuditLogger`, and wraps responses in the shared cursor envelope with regression coverage in `tests/Feature/Api/RFQQuoteControllerTest.php`._

2. High – rfq_quotes records are not tenant-scoped or soft-deleted (RFQQuote.php, lines 9‑60). The model extends bare Model, omits the BelongsToCompany trait, has no company_id fillable, and never enables SoftDeletes, contradicting “Every business table carries company_id + soft deletes” from CONVENTIONS.md. Without those columns, there is no way to filter or purge supplier quotes per tenant, and restoration is impossible. Add the columns & indexes via migration, update the model to extend CompanyScopedModel with SoftDeletes, and backfill existing rows.

	_Status: ✅ Migration `database/migrations/2025_12_05_120000_scope_rfq_quotes_and_invitations.php` adds `company_id`, soft deletes, and composite indexes to `rfq_quotes`, chunk-backfilling company IDs safely across drivers; `app/Models/RFQQuote.php` now extends `CompanyScopedModel` with `SoftDeletes`, factories set `company_id`, documents relationship added, and tests exercise tenant scoping._

3. High – RFQ invitations suffer the same tenant leak (RfqInvitation.php, lines 7‑44). Invitations lack company_id, the shared scope, and soft deletes even though the spec requires traceable multi-tenant audit trails for every RFQ interaction. A compromised supplier could read or mutate invitations from other buyers because nothing limits queries per company. Mirror the pattern used by RfqClarification (fillable company_id, CompanyScopedModel, SoftDeletes) and ensure controllers/policies always scope to the active tenant.

	_Status: ✅ The same migration scopes `rfq_invitations` (company column, soft deletes, deleted-aware unique index), `app/Models/RfqInvitation.php` now uses `CompanyScopedModel` + `SoftDeletes`, factories/action `app/Actions/Rfq/InviteSuppliersToRfqAction.php` assign/restores tenant data, and invitation queries respect the active company._

4. High – RFQ listing still emits offset pagination contrary to the platform contract (RFQController.php, lines 742‑780). buildRfqIndexResponse() calls $query->paginate(...) and returns a LengthAware payload; /[REQUIREMENTS_FULL.md](http://_vscodecontentref_/8) §26 mandates cursor pagination (data.items, meta.cursor.*) for every collection, which is what the React RFQ list already expects. Replace paginate() with cursorPaginate($this->perPage(...), ['*'], 'cursor', $request->query('cursor')), keep deterministic ordering (due_at, id), and update tests to assert meta.cursor.has_next flips when more RFQs exist.

	_Status: ✅ `app/Http/Controllers/Api/RFQController.php` now reads the `cursor` query param, replaces `paginate()` with deterministic `cursorPaginate()` ordering (sort column + id), and feeds the paginator through the shared API envelope; `tests/Feature/Api/RfqListingFiltersTest.php` covers the cursor metadata and multi-page traversal._

5. Medium – Purchase order listings reuse offset pagination (PurchaseOrderController.php, lines 34‑69). Just like the RFQ case, $query->paginate(...)->withQueryString() breaks the cursor contract and causes the SDK to stop after the first page for tenants with >25 orders. Switch to cursorPaginate, carry forward the supplier filter logic, and extend tests/Feature/Api/PurchaseOrderTest.php (or similar) with a cursor regression case.

	_Status: ✅ `app/Http/Controllers/Api/PurchaseOrderController.php::index()` now scopes by company + supplier filters, orders by issued_at/id, and returns `cursorPaginate()` results via the shared envelope; regression coverage lives in `tests/Feature/Api/PurchaseOrderActionsTest.php` which asserts `meta.cursor.has_next` flips across pages._

6. Medium – Purchase order event feeds ignore pagination altogether (PurchaseOrderController.php, lines 166‑205). events() simply ->limit(200)->get() and returns { items: [...] } without cursor metadata. Large orders will silently drop older events, violating the “all collection endpoints default to cursor pagination” requirement and the auditability standard in DEFINITION_OF_DONE.md. Wrap the relation in cursorPaginate, propagate meta.cursor, and strengthen tests to prove pagination works for >200 rows.

	_Status: ✅ Purchase order events now run through `cursorPaginate()` ordered by `occurred_at` then `id`, preserving tenant scope and emitting cursor metadata from `PurchaseOrderController@events`; `tests/Feature/Api/PurchaseOrderActionsTest.php` seeds >200 events to prove cursors expose the full audit trail._