1. API validation failures still bypass the required envelope metadata. ApiFormRequest.php (lines 14‑33) throws response()->json(...) without the { meta: { request_id, … } } block or X-Request-Id. SupplierApplicationStoreRequest::failedAuthorization() and StoreInvitationRequest::failedAuthorization() repeat the same pattern. Per API_ENVELOPE.md and the launch bible, every response—including 401/403/422 surfaces—must return the standard envelope so clients can correlate errors and observability retains request IDs. Right now 422s/403s omit meta.request_id, and the Axios helpers can’t extract cursor metadata from validation errors. Please route these failures through RespondsWithEnvelope (or a tiny helper) so we emit fail(...)/ok(...) consistently and set the X-Request-Id header.
**Status: ✅ Completed — `ApiFormRequest` now uses `RespondsWithEnvelope::fail()` for validation/authorization failures, and `SupplierApplicationStoreRequest` plus `StoreInvitationRequest` delegate to the same helper so every 403/422 emits the standard envelope with `meta.request_id`.**

2. Several live APIs still use plain FormRequest, so validation errors fall back to Laravel’s default redirect/HTML payload. Examples: UpsertFxRatesRequest.php and ListBuyerOrdersRequest.php both extend FormRequest and never override failedValidation. Hitting /api/fx-rates/upsert or /api/buyer/orders with an invalid payload currently produces a 302/HTML or a JSON body that lacks { status, message, data, meta }, which breaks the SDK contract and the acceptance checklist (“REST endpoints return the JSON envelope”). These requests should extend ApiFormRequest (or at least override failedValidation/failedAuthorization to delegate to RespondsWithEnvelope) so every FX/order error matches the platform contract.
**Status: ✅ Completed — `UpsertFxRatesRequest` and `Orders/ListBuyerOrdersRequest` now extend `ApiFormRequest`, inheriting envelope validation responses, and Upsert FX authorization failures emit `$this->fail()` with the billing-specific message, so both endpoints always return the standard API contract.**

3. Upload validators ignore the configurable document policy and hard-code a 10 MB cap plus a truncated MIME list. Examples: StoreQuoteRequest.php line 134 ( max:10240, explicit mimes:step,… ), the RFQ clarification payloads (StoreRfqQuestionRequest.php, StoreRfqAnswerRequest.php, StoreRfqAmendmentRequest.php) and ESG uploads (StoreEsgRecordRequest.php line 28). documents.php exposes max_size_mb (50 MB by default) and the authoritative extension list, and the copilot instructions explicitly say “always enforce module-specific size limits from config/documents.php”. Because these validators are hard-coded, any admin who bumps DOCUMENTS_MAX_SIZE_MB or adds CAD formats sees no effect, and legitimate CAD/DOCX/PDF uploads over 10 MB are rejected even though the storage layer accepts them. The fix is to read config('documents.allowed_extensions'), build the MIME/extension rules dynamically, and compute max in kilobytes from config('documents.max_size_mb') in every upload request.
**Status: ✅ Completed — Added `InteractsWithDocumentRules` to leverage `config('documents.*')` and updated all RFQ clarification, quote, and ESG upload requests (plus company document uploads) to pull extensions + max size from config so admin overrides propagate automatically.**

4. The customer-facing Orders module still hasn’t been implemented. orders-page.tsx renders ModulePlaceholder instead of the PO/order list, even though pos_orders.md mandates “PO List & Detail … Order Detail timeline with status chips.” As a result, buyers have no Inertia view to inspect the /api/buyer/orders data that already exists, so the RFQ → PO → Order journey cannot be completed from the UI. We need the actual Orders list/detail experience (filters, status pills, shipment timeline, empty/skeleton states) wired to the existing buyer/supplier order APIs before launch.
**Status: ✅ Completed — `OrdersPage` now renders `BuyerOrderListPage`, so the `/app/orders` nav entry loads the fully implemented buyer tracking UI with filters, fulfillment progress, shipment counts, and links into the detail view/timeline instead of the placeholder module.**

5. Open-bidding RFQ clarifications never reach suppliers. In app/Services/RfqClarificationService.php::resolveSupplierParticipants() lines 232‑260, when an RFQ has no explicit invitations (the common case for open bidding) the method returns collect() with a // TODO comment. REQUIREMENTS_FULL.md (§13 — “Every RFQ has a Clarifications thread visible to all invited suppliers (or public if ‘Open Bidding’)”) requires that public clarifications broadcast to the full approved supplier directory. Because the participant list stays empty, NotificationService never sends emails/in-app alerts for open-bidding clarifications, so suppliers are unaware of Q&A, amendments, or timeline changes. Mirror the logic already used in RFQController::supplierRecipients() (merge invited supplier company IDs with Company::listedSuppliers() when open_bidding is true) so clarifications notify all eligible suppliers and stay spec-compliant.
**Status: ✅ Completed — `RfqClarificationService::resolveSupplierParticipants()` now merges invited supplier company IDs with `Company::listedSuppliers()` whenever open bidding is enabled, so NotificationService fan-out includes every approved public supplier.**