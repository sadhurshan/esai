1. ~~**High – Asset maintenance links ignore tenant + soft-delete requirements.** `database/migrations/2025_11_10_150800_create_asset_procedure_links_table.php` creates `asset_procedure_links` without a `company_id` column or `deleted_at`, and `app/Models/AssetProcedureLink.php` extends the base `Model` without `BelongsToCompany` or `SoftDeletes`. The project bible (`docs/DB_PLAN.md` and `/docs/REQUIREMENTS_FULL.md` §26) states that *every* business table must carry `company_id` and soft deletes so queries can be tenant-scoped and audit/restoration friendly. Because this pivot stores scheduling metadata (frequency, next_due_at, meta) it is business data, yet nothing prevents a tenant from loading another company's maintenance links or resurrecting deleted schedules. **Fix:** add `company_id`, `deleted_at`, and the required composite indexes; backfill the column from each linked asset; update the model to extend `CompanyScopedModel` with `SoftDeletes`, factories/seeders to set `company_id`, and adjust `MaintenancePlanner` queries to use the scoped relation instead of raw `where('asset_id', …)`.~~ **(Fixed)** — Migration `2025_12_09_000001_add_company_scope_to_maintenance_tables.php` adds `company_id`, soft deletes, scoped indexes, and FK enforcement (with data backfill) for `asset_procedure_links`; `AssetProcedureLink` now extends `CompanyScopedModel` + `SoftDeletes`, factories populate tenant data, and `MaintenancePlanner` queries the asset relation so company scope is always applied.

2. ~~**High – Procedure steps also lack tenant scope and soft deletes.** `database/migrations/2025_11_10_150700_create_procedure_steps_table.php` omits both `company_id` and `deleted_at`, and `app/Models/ProcedureStep.php` again extends bare `Model` with no tenant guard. The maintenance module requirements (Digital Twin & Maintenance Library sections in `docs/REQUIREMENTS_FULL.md`) call for per-tenant procedures with audit history. As implemented, steps inherit nothing from `maintenance_procedure_id`, so a deleted step is hard-removed and any query that forgets to join through the parent can bleed data across tenants. **Fix:** follow the same remediation pattern—add `company_id` + soft deletes via migration (backfilling from the parent procedure), make the model extend `CompanyScopedModel` with `SoftDeletes`, ensure factories populate the column, and update relationships so eager loads remain scoped (e.g., `->with(['steps' => fn ($q) => $q->orderBy('step_no')])`).~~ **(Fixed)** — The same migration now adds `company_id`, `deleted_at`, indexed constraints, and backfills for `procedure_steps`; `ProcedureStep` extends `CompanyScopedModel` with soft deletes and the factory seeds tenant IDs so maintenance procedures/steps stay in sync.

3. ~~**Medium – Purchase order listing still emits offset pagination.** `app/Http/Controllers/Api/PurchaseOrderController.php::index` (lines ~41-103) calls `$query->paginate()` and fakes a "cursor" by casting the request cursor to a page number. The platform contract (copilot instructions + `docs/REQUIREMENTS_FULL.md` §26) requires every collection endpoint to expose cursor pagination with `{ data: { items }, meta: { next_cursor, prev_cursor, per_page } }`. Because this endpoint returns LengthAware metadata instead, the React hooks (`usePurchaseOrders`), SDK, and QA scripts that now assume real cursors cannot advance past the first page, and the API no longer matches OpenAPI. This gap was already called out in launch cleanup #08/#15 but never fixed. **Fix:** switch to `cursorPaginate($this->perPage(...), ['*'], 'cursor', $request->query('cursor'))` with deterministic ordering (`orderByDesc('created_at')->orderByDesc('id')`), feed the result through `$this->paginate()`, and return the helper's `$meta` block so clients regain cursor tokens.~~ **(Fixed)** — `PurchaseOrderController@index` now uses deterministic `cursorPaginate(...)->withQueryString()` and returns the shared cursor metadata via `ApiController::paginate`, restoring spec-compliant envelopes for the PO list and SDK hooks.

4. ~~**Medium – Global GRN listing regressed to offset pagination.** `app/Http/Controllers/Api/GoodsReceiptNoteController.php::companyIndex` (lines ~30-110) once again uses `$query->paginate()` and passes the LengthAware metadata straight through. The receiving deep spec never authorizes exceptions, and `docs/launch_ready_cleanup/Gaps and Errors Findings 08.md` + #15 explicitly tracked this endpoint until it supposedly switched to cursors. Without real cursor metadata the `/receiving/grns` page and SDK (`useGrns`) stall on the first page for tenants with >25 receipts, violating the API envelope rule. **Fix:** mirror the PO-scoped index implementation: order by `inspected_at`, `created_at`, `id`, run `cursorPaginate`, and return the shared cursor meta.~~ **(Fixed)** — `companyIndex` now enforces cursor pagination (inspected_at/id ordering + shared cursor meta), so `/receiving/grns` and the SDK regain `next_cursor/prev_cursor` support.

5. ~~**Medium – Purchase order shipments endpoint returns unbounded arrays.** `app/Http/Controllers/Api/PurchaseOrderShipmentController.php::index` loads every shipment via `->get()` and returns `{ items: [...] }` with no pagination or envelope meta. The shipments list is exposed under `/purchase-orders/{id}/shipments`, and per the API contract every collection must be cursor-paginated with top-level `meta.next_cursor/meta.prev_cursor`. Large orders (multiple partial shipments) will send potentially hundreds of rows per request, and the React detail page cannot request additional pages or show "Load more" controls. **Fix:** apply the standard pattern—wrap the relation in `cursorPaginate($this->perPage(...), ['*'], 'cursor', $request->query('cursor'))`, keep deterministic ordering (`orderByDesc('shipped_at')->orderByDesc('id')`), pass the cursor block to `$this->ok()`, and add feature tests similar to `PurchaseOrderEventsTest` to lock the behavior down.~~ **(Fixed)** — The shipments endpoint now wraps the relation in cursor pagination, serializes via `ApiController::paginate`, and returns envelope-level cursor metadata so UI/API consumers can page through large shipment histories.
